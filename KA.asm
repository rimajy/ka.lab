.model small
.stack 100h

.data
buffer  db 255 dup(?)  ; буфер для зберігання введених даних
numbers dw 10000 dup(?) ; масив для зберігання чисел

.code
start:
    mov ax, @data
    mov ds, ax

    mov cx, 0  ; лічильник чисел

read_loop:
    mov ah, 3Fh       ; зчитування з stdin
    mov bx, 0         ; stdin handle
    mov cx, 255       ; максимальна довжина рядка
    lea dx, buffer    ; буфер для зберігання рядка
    int 21h

    mov si, offset buffer  ; si вказує на початок рядка

parse_loop:
    mov bl, [si]      ; завантаження символу
    cmp bl, ' '       ; перевірка на пробіл
    je add_number     ; якщо пробіл, перейти до додавання числа

    cmp bl, 0         ; перевірка на кінець рядка
    je add_number     ; якщо кінець рядка, перейти до додавання числа

    sub bl, '0'       ; конвертація символу у число
    mov cx, ax        ; зберігаємо ax у cx
    shl ax, 1         ; множення ax на 10
    add ax, cx        ; додавання нової цифри
    add ax, ax        ; множення на 2 для ефективності (ax = ax * 10)
    add ax, bx        ; додавання цифри до ax

    inc si            ; перехід до наступного символу
    jmp parse_loop    ; повторення парсингу

add_number:
    mov bx, cx          ; поміщаємо значення cx до bx для обчислення зміщення
    shl bx, 1           ; масштабування bx на 2, оскільки кожне число двобайтове

    lea di, numbers     ; завантаження адреси масиву numbers до регістра di
    mov [di + bx], ax   ; збереження числа в масиві з обчисленим зміщенням

    ; Перевірка на від'ємне число
    mov ax, [di + bx]   ; Завантажуємо число до ax
    test ax, 8000h      ; Перевіряємо найстарший біт
    jnz negative_number ; Якщо найстарший біт встановлений (від'ємне число), переходимо до negative_number

    inc cx                      ; збільшення лічильника чисел

    cmp bl, 0         ; перевірка на кінець вводу
    je sort_numbers    ; якщо кінець вводу, переходимо до сортування чисел

    jmp read_loop      ; повторення зчитування

negative_number:
    ; Конвертуємо від'ємне число в його двійкове представлення у вигляді доповнювального коду
    neg ax             ; Від'ємне число: беремо доповнення до двійки
    not ax             ; Перевертаємо всі біти

    ; Від'ємне число в доповнювальному коді зберігається в [di + bx]

    inc cx             ; збільшення лічильника чисел

    cmp bl, 0         ; перевірка на кінець вводу
    je sort_numbers    ; якщо кінець вводу, переходимо до сортування чисел

    jmp read_loop      ; повторення зчитування

sort_numbers:
    ; Сортування чисел
    mov cx, word ptr cx     ; Завантажуємо кількість чисел до cx
    dec cx                  ; count-1
outerLoop:
    push cx
    lea si, numbers
innerLoop:
    mov ax, [si]
    cmp ax, [si+2]
    jl nextStep
    xchg [si+2], ax
    mov [si], ax
nextStep:
    add si, 2
    loop innerLoop
    pop cx
    loop outerLoop
    ; Обчислення медіани
mov ax, cx               ; Завантаження кількості чисел до ax
shr ax, 1                ; Знаходимо середнє значення (половина чисел)
jnc even_median          ; Перевіряємо, чи кількість чисел парна
mov dx, [numbers+bx]     ; Якщо кількість чисел непарна, медіана - значення середнього елемента
jmp median_found
even_median:
mov ax, [numbers+bx]     ; Якщо кількість чисел парна, медіана - середнє значення двох середніх елементів
add ax, [numbers+bx+2]
shr ax, 1
median_found:
; Значення медіани знаходиться у регістрі ax

; Обчислення середнього значення
xor dx, dx               ; Обнуляємо DX для накопичення 32-бітного результату
mov cx, 0                ; Обнуляємо CX для використання у циклі
lea si, numbers
average_loop:
add ax, [si]             ; Додаємо 16-бітне число до 32-бітного результату
adc dx, 0                ; Переносимо з флагом CF, щоб обробити переповнення
add si, 2                ; Переходимо до наступного числа
loop average_loop        ; Повторюємо для всіх чисел

; Ділимо суму на кількість чисел
mov bx, cx               ; Завантажуємо кількість чисел у bx
mov dx, 0FFh             ; Частина високих бітів
div bx                   ; DX:AX / кількість чисел, результат в AX

; AX містить середнє значення

; Виведення медіани та середнього значення у десятковому форматі
; (Вам може знадобитися функція конвертації чисел до рядка)

; Приклад виведення медіани
mov dx, ax               ; Завантаження значення медіани у DX
mov ah, 2                ; Функція DOS для виведення символа
int 21h                  ; Виведення числа на екран

; Приклад виведення середнього значення
mov dx, ax               ; Завантаження середнього значення у DX
mov ah, 2                ; Функція DOS для виведення символа
int 21h                  ; Виведення числа на екран

end_program:
    mov ah, 4Ch        ; вихід з програми
    int 21h
end start









